template <class Enum, std::size_t N>
inline constexpr FlagSet<Enum, N>::FlagSet(std::initializer_list<Enum> flags)
{
	for(auto& flag : flags)
		set(flag);
}

template <class Enum, std::size_t N>
inline FlagSet<Enum, N>& FlagSet<Enum, N>::operator=(std::initializer_list<Enum> flags)
{
	operator=(FlagSet(flags));
	return *this;
}

template <class Enum, std::size_t N>
inline bool FlagSet<Enum, N>::operator==(const FlagSet<Enum, N>& rhs) const
{
	return m_bitset == rhs.m_bitset;
}

template <class Enum, std::size_t N>
inline bool FlagSet<Enum, N>::operator!=(const FlagSet<Enum, N>& rhs) const
{
	return m_bitset != rhs.m_bitset;
}

template <class Enum, std::size_t N>
inline bool FlagSet<Enum, N>::test(Enum flag) const throw(std::out_of_range)
{
	return m_bitset.test(getIndex(flag));
}

template <class Enum, std::size_t N>
inline bool FlagSet<Enum, N>::all() const noexcept
{
	return m_bitset.all();
}

template <class Enum, std::size_t N>
inline bool FlagSet<Enum, N>::any() const noexcept
{
	return m_bitset.any();
}

template <class Enum, std::size_t N>
inline bool FlagSet<Enum, N>::none() const noexcept
{
	return m_bitset.none();
}

template <class Enum, std::size_t N>
inline std::size_t FlagSet<Enum, N>::count() const
{
	return m_bitset.count();
}

template <class Enum, std::size_t N>
inline constexpr std::size_t FlagSet<Enum, N>::size() const noexcept
{
	return m_bitset.size();
}

template <class Enum, std::size_t N>
inline FlagSet<Enum, N>& FlagSet<Enum, N>::operator&=(const FlagSet<Enum>& other)
{
	m_bitset.operator&=(other.m_bitset);
	return *this;
}

template <class Enum, std::size_t N>
inline FlagSet<Enum, N>& FlagSet<Enum, N>::operator|=(const FlagSet<Enum>& other)
{
	m_bitset.operator|=(other.m_bitset);
	return *this;
}

template <class Enum, std::size_t N>
inline FlagSet<Enum, N>& FlagSet<Enum, N>::operator^=(const FlagSet<Enum>& other)
{
	m_bitset.operator^=(other.m_bitset);
	return *this;
}

template <class Enum, std::size_t N>
inline FlagSet<Enum, N> FlagSet<Enum, N>::operator~() const
{
	FlagSet<Enum, N> res(*this);
	res.m_bitset.operator~();
	return res;
}

template <class Enum, std::size_t N>
inline FlagSet<Enum, N>& FlagSet<Enum, N>::set()
{
	m_bitset.set();
	return *this;
}

template <class Enum, std::size_t N>
inline FlagSet<Enum, N>& FlagSet<Enum, N>::set(Enum flag, bool value)
{
	m_bitset.set(getIndex(flag), value);
	return *this;
}

template <class Enum, std::size_t N>
inline FlagSet<Enum, N>& FlagSet<Enum, N>::reset()
{
	m_bitset.reset();
	return *this;
}

template <class Enum, std::size_t N>
inline FlagSet<Enum, N>& FlagSet<Enum, N>::reset(Enum flag)
{
	m_bitset.set(getIndex(flag));
	return *this;
}

template <class Enum, std::size_t N>
inline FlagSet<Enum, N>& FlagSet<Enum, N>::flip()
{
	m_bitset.flip();
	return *this;
}

template <class Enum, std::size_t N>
inline FlagSet<Enum, N>& FlagSet<Enum, N>::flip(Enum flag)
{
	m_bitset.flip(getIndex(flag));
	return *this;
}

template <class Enum, std::size_t N>
inline std::size_t FlagSet<Enum, N>::getIndex(Enum flag) const
{
	return static_cast<std::size_t>(flag);
}


template<class Enum, std::size_t N>
inline FlagSet<Enum, N> operator&(FlagSet<Enum, N> lhs, const FlagSet<Enum, N>& rhs)
{
	return lhs &= rhs;
}

template<class Enum, std::size_t N>
inline FlagSet<Enum, N> operator|(FlagSet<Enum, N> lhs, const FlagSet<Enum, N>& rhs)
{
	return lhs |= rhs;
}

template<class Enum, std::size_t N>
inline FlagSet<Enum, N> operator^(FlagSet<Enum, N> lhs, const FlagSet<Enum, N>& rhs)
{
	return lhs ^= rhs;
}
